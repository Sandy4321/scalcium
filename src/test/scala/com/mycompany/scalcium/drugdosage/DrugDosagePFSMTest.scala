package com.mycompany.scalcium.drugdosage

import java.io.File
import java.io.FileWriter
import java.io.PrintWriter

import scala.Array.canBuildFrom
import scala.collection.mutable.ArrayBuffer
import scala.io.Source

import org.junit.Ignore
import org.junit.Test

import com.mycompany.scalcium.utils.DictNER
import com.mycompany.scalcium.utils.NGram
import com.mycompany.scalcium.utils.RegexNER

class DrugDosagePFSMTest {

  val datadir = "src/main/resources/drug_dosage"
  val tmpdir = "/tmp"
    
  @Test
  @Ignore
  def testComputeTransitionFrequencies(): Unit = {
    val dictNER = new DictNER(Map(
      ("DRUG", new File(datadir, "drugs.dict")),
      ("FREQ", new File(datadir, "frequencies.dict")),
      ("ROUTE", new File(datadir, "routes.dict")),
      ("UNIT", new File(datadir, "units.dict"))))
    val regexNER = new RegexNER(Map(
      ("NUM", new File(datadir, "num_patterns.dict"))    
    ))
    val transitions = ArrayBuffer[(String,String)]()
    Source.fromFile(new File(datadir, "input.txt"))
      .getLines()
      .foreach(line => {
        val dictTags = dictNER.tag(line)
        val regexTags = regexNER.tag(line)
        val mergedTags = dictNER.merge(List(dictTags, regexTags))
        val tagBigrams = NGram.bigrams(mergedTags.map(_._2))
          .map(bigram => transitions += 
            ((bigram(0).asInstanceOf[String], 
             bigram(1).asInstanceOf[String])))
    })
    val transitionFreqs = transitions
      .groupBy(pair => pair._1 + " -> " + pair._2)
      .map(pair => (pair._1, pair._2.size))
      .toList
      .sortBy(pair => pair._1)
    Console.println(transitionFreqs.mkString("\n"))
  }  

  @Test
  @Ignore
  def testParse(): Unit = {
    val ddPFSM = new DrugDosagePFSM(
        new File(datadir, "drugs.dict"),
        new File(datadir, "frequencies.dict"),
        new File(datadir, "routes.dict"),
        new File(datadir, "units.dict"),
        new File(datadir, "num_patterns.dict"),
        false)
    val writer = new PrintWriter(new FileWriter(
      new File(datadir, "pfsm_output.txt")))
    Source.fromFile(new File(datadir, "input.txt"))
      .getLines()
      .foreach(line => {
         val stab = ddPFSM.parse(line)
         writer.println(line)
         writer.println(stab.map(st => st._2 + "/" + st._1)
           .mkString(" "))
         writer.println()
    })
    writer.flush()
    writer.close()
  }

  @Test
  @Ignore
  def testEvaluateAccuracy(): Unit = {
    val accuracies = ArrayBuffer[Double]()
    (0 until 10).foreach(cv => {
      // get random list of rows that will be our test case
      val testrows = scala.collection.mutable.Set[Int]()
      val random = scala.util.Random
      do {
        testrows += (random.nextDouble * 100).toInt
      } while (testrows.size < 30)
      // test random 30% data of input. There
      // is no training involved here, so we just test
      // our parser against the "gold" set from model.train
      // generated by rule-based dict and regex NERs.
      val inputfile = new File(datadir, "model.train")
      var curr = 0
      var results = ArrayBuffer[Int]()
      Source.fromFile(inputfile)
        .getLines()
        .foreach(line => {
        if (testrows.contains(curr)) {
          val words = line.split(" ").map(wordTag => 
            wordTag.substring(0, wordTag.lastIndexOf('/')))
            .mkString(" ")
          val rtags = line.split(" ").map(wordTag => 
            wordTag.substring(wordTag.lastIndexOf('/') + 1))
            .toList
          val ddPFSM = new DrugDosagePFSM(
            new File(datadir, "drugs.dict"),
            new File(datadir, "frequencies.dict"),
            new File(datadir, "routes.dict"),
            new File(datadir, "units.dict"),
            new File(datadir, "num_patterns.dict"),
            false)
          val ptags = ddPFSM.parse(words)
            .map(wordTag => wordTag._2)
          val result = (0 until List(rtags.size, ptags.size).min)
            .map(i => if (rtags(i).equals(ptags(i))) 1 else 0)
          results ++= result
        }
        curr += 1
      })
      val accuracy = results.sum.toDouble / results.size
      Console.println("CV #%d: accuracy=%f".format(cv, accuracy))
      accuracies += accuracy
    })
    Console.println("Overall accuracy=%f".format(
      accuracies.sum / accuracies.size))
  }
}
